use rand::rngs::StdRng;
use rand::SeedableRng;
use rand::Rng;

use std::env::args;
use std::fs;
use std::time::Instant;

use serde_derive::Deserialize;

use realms::*;

const REAL_WINDOW_FPS: f32 = 120.0;

#[derive(Deserialize)]
struct Config {
    width: usize,
    height: usize,
    pixelate: usize,
    initial_x: i32,
    initial_y: i32,
    color_magnitude: i32,
    color_interval: usize,
    color_red: u8,
    color_green: u8,
    color_blue: u8,
    speed: usize,
    rect_size: usize,
}

fn main() {
    let mut direction = [1i32, 1i32];
    let args: Vec<String> = args().collect();

    let path = match args.get(1) {
        Some(path) => path,
        None => "config.toml",
    };

    if !fs::exists(path).expect("failed to check if the config.toml file exists") {
        fs::write(path, r#"# auto config for coolvis
width = 600 # the width of the window
height = 590 # the height of the window
pixelate = 5 # higher values mean more pixelation
initial_x = 150 # the X coordinate of the top-left corner of the square
initial_y = 200 # the Y coordinate of the top-left corner of the square
color_interval = 10 # how many frames are skipped until the color changes. HIGHER = SLOWER color change
color_magnitude = 7 # how much the color changes on each color interval. HIGHER = FASTER color change
color_red = 63 # the red component of the starting color
color_green = 191 # the green component of the starting color
color_blue = 31 # the blue component of the starting color
speed = 10000 # the number of squares drawn per second (runtime speed)
rect_size = 32 # the width and height of the square

# This config.toml was autogenerated by coolvis at startup. If you mess up your
# config later on, you can delete config.toml and coolvis will create a new one
# when you next run the program.
# For a full guide to using and configuring coolvis, please see the coolvis
# book at https://github.com/dylanopen/coolvis.
# Please send any cool visualisations you create to opendylan@proton.me!
"#      ).expect("failed to create initial config.toml file")
    }

    let config: Config = match toml::from_str(&fs::read_to_string(path).unwrap()) {
        Ok(config) => config,
        Err(err) => panic!(
            "\n\x1b[32m\x1b[1m\x1b[4m\tCOOLVIS COULDN'T UNDERSTAND YOUR CONFIG FILE:\n\n\x1b[0m\x1b[31m\x1b[1m{}  \x1b[0m\n",
            err
        ),
    };

    let mut x = config.initial_x;
    let mut y = config.initial_y;
    let mut color = Color::rgb(
        config.color_red,
        config.color_green,
        config.color_blue,
    );

    let mut rng = StdRng::seed_from_u64((
        config.color_interval * 256*256*32*64
        + config.color_magnitude as usize * 256*256*32
        + color.r as usize * 256*256
        + color.g as usize * 256
        + color.b as usize 
    ) as u64);

    let mut w = Window::new(
        &format!("coolvis: by Dylan Rogers - {}", path),
        config.width as usize, config.height as usize
    );
    w.set_fps(REAL_WINDOW_FPS as usize);

    Rect::fill(&w, Color::rgb(255, 255, 255)).draw(&mut w);

    let program_start = Instant::now();
    let mut total_draws = 0;

    while w.is_running() {
        w.new_frame();

        let mut frame_iters = 0;
        loop {
            if frame_iters as f32 >= config.speed as f32 / config.pixelate as f32 / REAL_WINDOW_FPS { break; }

            if total_draws % config.color_interval == 0 {
                color.r = (color.r as i32 + rng.random_range(-config.color_magnitude..=config.color_magnitude)).clamp(0, 255) as u8;
                color.g = (color.g as i32 + rng.random_range(-config.color_magnitude..=config.color_magnitude)).clamp(0, 255) as u8;
                color.b = (color.b as i32 + rng.random_range(-config.color_magnitude..=config.color_magnitude)).clamp(0, 255) as u8;
            }

            if x < 0 { direction[0] = 1 }
            if x > config.width as i32 - config.rect_size as i32 { direction[0] = -1 }
            if y < 0 { direction[1] = 1 }
            if y > config.height as i32 - config.rect_size as i32 { direction[1] = -1 }

            x += direction[0] * config.pixelate as i32;
            y += direction[1] * config.pixelate as i32;

            Rect::new(
                Vec2f::new(x as f32, y as f32),
                Vec2f::new(config.rect_size as f32, config.rect_size as f32),
                color.clone()
            ).draw(&mut w);
            frame_iters += 1;
            total_draws += 1;
        }
    }

    let runtime = program_start.elapsed().as_secs_f32();
    println!(
        "{} rectangles were drawn in the {} seconds of runtime, averaging {} rectangles drawn per second ({}% of expected).",
        total_draws, runtime,
        total_draws as f32 / runtime,
        ((total_draws as f32 / runtime) / (config.speed / config.pixelate) as f32 * 100.0).min(100.0),
    );

    w.close();
}

